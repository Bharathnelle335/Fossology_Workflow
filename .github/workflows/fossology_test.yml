name: Fossology Test (Multi-Format SPDX + Token Split + Conversion)

on:
  workflow_dispatch:
    inputs:
      scan_type:
        description: "Type of scan"
        required: true
        default: "docker"
        type: choice
        options: [docker, repo, file]
      docker_image:
        required: false
      repo_url:
        required: false
      file_path:
        required: false
      token_days:
        required: true
        default: "7"
      agents_nomos:
        default: "true"
        type: boolean
      agents_monk:
        default: "false"
        type: boolean
      agents_copyright:
        default: "true"
        type: boolean
      agents_email:
        default: "false"
        type: boolean
      agents_keyword:
        default: "false"
        type: boolean

jobs:
  fossology:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare input file
        run: |
          case "${{ github.event.inputs.scan_type }}" in
            docker)
              docker pull ${{ github.event.inputs.docker_image }}
              docker save ${{ github.event.inputs.docker_image }} -o docker-image.tar
              FILE_TO_UPLOAD="docker-image.tar"
              MIME_TYPE="application/x-tar"
              ;;
            repo)
              git clone "${{ github.event.inputs.repo_url }}" repo/
              tar -czf repo.tar.gz -C repo .
              FILE_TO_UPLOAD="repo.tar.gz"
              MIME_TYPE="application/x-tar"
              ;;
            file)
              echo "File path: ${{ github.event.inputs.file_path }}" > file.txt
              echo "# SPDX-License-Identifier: MIT" >> file.txt
              echo "# Copyright 2025 Bharath Technologies" >> file.txt
              FILE_TO_UPLOAD="file.txt"
              MIME_TYPE="text/plain"
              ;;
          esac
          echo "FILE_TO_UPLOAD=$FILE_TO_UPLOAD" >> $GITHUB_ENV
          echo "MIME_TYPE=$MIME_TYPE" >> $GITHUB_ENV

      - name: Start Fossology and acquire token
        run: |
          docker run -d --name fossy -p 8081:80 fossology/fossology:4.3.0
          echo "‚è≥ Waiting for Fossology to start..."
          sleep 60

          EXPIRY=$(date -d "+${{ github.event.inputs.token_days }} days" +%Y-%m-%d)
          AUTH_RESP=$(curl -s -X POST "http://localhost:8081/repo/api/v1/tokens" \
            -H "accept: application/json" \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"fossy\", \"password\": \"fossy\", \"token_name\": \"github-actions\", \"token_scope\": \"write\", \"token_expire\": \"$EXPIRY\"}")

          RAW_TOKEN=$(echo "$AUTH_RESP" | jq -r '.Authorization' | sed 's/^Bearer //' | tr -d '\r\n[:space:]')
          if [ -z "$RAW_TOKEN" ] || [ "$RAW_TOKEN" = "null" ]; then
            echo "‚ùå Failed to get token"
            echo "Response: $AUTH_RESP"
            exit 1
          fi

          mkdir token_parts
          printf "%s" "${RAW_TOKEN:0:60}" > token_parts/part1.txt
          printf "%s" "${RAW_TOKEN:60:60}" > token_parts/part2.txt
          printf "%s" "${RAW_TOKEN:120}" > token_parts/part3.txt

          echo "‚úÖ Token acquired, valid until $EXPIRY"
          for f in token_parts/part*.txt; do
            LEN=$(wc -c < "$f" | tr -d ' ')
            HASH=$(sha256sum "$f" | cut -d' ' -f1)
            echo " - $(basename "$f"): length=$LEN, sha256=$HASH"
          done

      - name: Upload file to Fossology
        run: |
          AUTH_HEADER="Bearer $(<token_parts/part1.txt)$(<token_parts/part2.txt)$(<token_parts/part3.txt)"
          echo "üì§ Uploading $FILE_TO_UPLOAD to Fossology..."
          UPLOAD_RESP=$(curl -s -w "\n%{http_code}" -X POST "http://localhost:8081/repo/api/v1/uploads" \
            -H "accept: application/json" \
            -H "folderId: 1" \
            -H "public: public" \
            -H "applyGlobal: false" \
            -H "ignoreScm: false" \
            -H "uploadType: file" \
            -H "Authorization: $AUTH_HEADER" \
            -F "fileInput=@$FILE_TO_UPLOAD;type=$MIME_TYPE")

          HTTP_BODY=$(echo "$UPLOAD_RESP" | head -n -1)
          HTTP_STATUS=$(echo "$UPLOAD_RESP" | tail -n 1)

          if [ "$HTTP_STATUS" -ne 201 ]; then
            echo "‚ùå Upload failed with status $HTTP_STATUS"
            echo "Response: $HTTP_BODY"
            exit 1
          fi

          UPLOAD_ID=$(echo "$HTTP_BODY" | jq -r '.message')
          echo "UPLOAD_ID=$UPLOAD_ID" >> $GITHUB_ENV
          echo "‚úÖ Uploaded with ID: $UPLOAD_ID"

      - name: Wait for folder ID
        run: |
          echo "‚è≥ Waiting for upload $UPLOAD_ID to be ready..."
          while true; do
            AUTH_HEADER="Bearer $(<token_parts/part1.txt)$(<token_parts/part2.txt)$(<token_parts/part3.txt)"
            UPLOAD_INFO=$(curl -s -X GET "http://localhost:8081/repo/api/v1/uploads/$UPLOAD_ID" \
              -H "accept: application/json" \
              -H "Authorization: $AUTH_HEADER")

            FOLDER_ID=$(echo "$UPLOAD_INFO" | jq -r '.folderid // empty')
            if [[ "$FOLDER_ID" =~ ^[0-9]+$ ]]; then
              echo "FOLDER_ID=$FOLDER_ID" >> $GITHUB_ENV
              echo "üìÇ Using folder ID: $FOLDER_ID"
              break
            fi

            MSG=$(echo "$UPLOAD_INFO" | jq -r '.message // empty')
            echo "   Still processing: $MSG"
            sleep 2
          done

      - name: Trigger Fossology agents
        run: |
          ANALYSIS_JSON=$(jq -n \
            --argjson nomos $([[ "${{ github.event.inputs.agents_nomos }}" == "true" ]] && echo true || echo false) \
            --argjson monk $([[ "${{ github.event.inputs.agents_monk }}" == "true" ]] && echo true || echo false) \
            --argjson copyright $([[ "${{ github.event.inputs.agents_copyright }}" == "true" ]] && echo true || echo false) \
            --argjson email $([[ "${{ github.event.inputs.agents_email }}" == "true" ]] && echo true || echo false) \
            --argjson keyword $([[ "${{ github.event.inputs.agents_keyword }}" == "true" ]] && echo true || echo false) \
            '{nomos:$nomos, monk:$monk, copyright:$copyright, email:$email, keyword:$keyword}')

          AUTH_HEADER="Bearer $(<token_parts/part1.txt)$(<token_parts/part2.txt)$(<token_parts/part3.txt)"
          JOB_RESP=$(curl -s -X POST "http://localhost:8081/repo/api/v1/jobs" \
            -H "accept: application/json" \
            -H "folderId: $FOLDER_ID" \
            -H "uploadId: $UPLOAD_ID" \
            -H "Content-Type: application/json" \
            -H "Authorization: $AUTH_HEADER" \
            -d "{\"analysis\": $ANALYSIS_JSON}")

          JOB_ID=$(echo "$JOB_RESP" | jq -r '.message // .id')
          echo "‚è≥ Waiting for job $JOB_ID to complete..."
          while true; do
            AUTH_HEADER="Bearer $(<token_parts/part1.txt)$(<token_parts/part2.txt)$(<token_parts/part3.txt)"
            STATUS=$(curl -s -X GET "http://localhost:8081/repo/api/v1/jobs/$JOB_ID" \
              -H "accept: application/json" \
              -H "Authorization: $AUTH_HEADER" | jq -r '.status')
            echo "Job status: $STATUS"
            [[ "$STATUS" == "Completed" ]] && break
            [[ "$STATUS" == "Failed" ]] && exit 1
            sleep 10
          done

      - name: Fetch Fossology reports (valid formats only)
        run: |
          mkdir -p fossology_reports
          valid_formats=("spdx2" "spdx2tv" "dep5" "readmeoss" "unifiedreport" "clixml" "decisionexporter")

          for format in "${valid_formats[@]}"; do
            echo "üìÑ Fetching report in $format format..."
            AUTH_HEADER="Bearer $(<token_parts/part1.txt)$(<token_parts/part2.txt)$(<token_parts/part3.txt)"
            REPORT=$(curl -s -X GET "http://localhost:8081/repo/api/v1/report?uploadId=$UPLOAD_ID&reportFormat=$format" \
              -H "accept: application/json" \
              -H "Authorization: $AUTH_HEADER")

            if echo "$REPORT" | jq . >/dev/null 2>&1; then
              echo "$REPORT" > "fossology_reports/report_${format}.json"
              echo "‚úÖ Saved: report_${format}.json"
            else
              echo "$REPORT" > "fossology_reports/report_${format}.txt"
              echo "‚ö†Ô∏è Non-JSON output saved: report_${format}.txt"
            fi
          done

      - name: Convert SPDX JSON to YAML and Markdown (with fallback)
        run: |
          echo "üîÑ Converting SPDX JSON to YAML and Markdown..."
          SUCCESS=true
          mkdir -p fossology_reports

          # YAML conversion
          if command -v yq >/dev/null; then
            if yq -P fossology_reports/report_spdx2.json > fossology_reports/report_spdx2.yaml; then
              echo "‚úÖ Converted JSON ‚Üí YAML"
            else
              echo "‚ö†Ô∏è Failed to convert JSON to YAML"
              SUCCESS=false
            fi
          else
            echo "‚ö†Ô∏è yq not installed, skipping YAML conversion"
            SUCCESS=false
          fi

          # Markdown conversion
          echo "# SPDX License Summary" > fossology_reports/report_spdx2.md
          if jq -e '.files | type == "array"' fossology_reports/report_spdx2.json > /dev/null; then
            jq -r '.files[] | "- **File**: \(.fileName)\n  - **Licenses**: \([.licenses[]?.shortName] // ["NO LICENSE"])"' \
              fossology_reports/report_spdx2.json >> fossology_reports/report_spdx2.md
            echo "‚úÖ Converted JSON ‚Üí Markdown"
          else
            echo "‚ö†Ô∏è SPDX JSON is invalid or missing .files[]. Skipping Markdown conversion"
            echo "_SPDX report could not be parsed. See JSON for details._" >> fossology_reports/report_spdx2.md
            SUCCESS=false
          fi

          if [ "$SUCCESS" = false ]; then
            echo "‚ö†Ô∏è One or more conversions failed. Proceeding to upload raw SPDX files only."
          fi

      - name: Upload all SPDX reports
        uses: actions/upload-artifact@v4
        with:
          name: SPDX-All-Formats
          path: fossology_reports/